Api? types of api? e.g.? web api? How web API works? How to use public web API in general?
REST? REST API? CRUD?
DRF ? Why to use DRF?
json library .dumps, .loads ? 
seraializers? serializer class, how to create serializer class? Flow of serializing data present in db? JSONReponse?
serializer fields
Deserialization? flow? io.BytesIO, streamdata? JSONParser? serializer.is_valid(), .save(), .validated_data, .errors? 
	How to write create(self, validated_data) function in serializer class ? What happens when you do .save() ?
	How to write update(self, instnace, validate_data) function? ALL CRUD opertions?
Class Based View?, How to write URL for class Based view? 





Api? 
Intermediate agent that allows two or more applications to communicate 
with each other.  

types: private(used within org), partner(used by partner/client), 
public(third party services)

e.g.: application(consumer) -- google Map API -- gmap(provider)

application contact api and gmap exposes its services via api 

With api we can have single db and multiple applications(web, android, ..)
If i want to create a adnroid application of my website. Then that android
app to work, what all services are required are exposed via api.

Web API? 
Api which is interface for web is web api. It may consist of one or more 
endpoints to define request and response.


How web API works? 
clientWeb(HTTP request) -- api -- webapp/db
client makes http request to api. api communicate to db. 
db provides required date to api. api returns data to client.   

data returned is in json or xml format. 

How to use public web API in general?  
register to API
API prvides api key apiKey: 274848hdjvb838823
Whenever you need kto communicate with server make request with api key 
e.g.: http://vector.com/?key=274848hdjvb838823
If API key aunthentication succeed, API will provide required data. 


REST:
It is just an architectural guideline to develop webapi.

REST API:
The api which is developed using REST is know an REST API/ RESTful API. 

CRUD:
Operation - HTTP_methods - Description  
Create - POST - Creating/posting/inserting data
Read - GET
Update - PUT,PATCH - PUT for complete data to be updated, PATCH for partial update 
delete - DELETE - Deleting data 

e.g.:
http://geekyshows.com/api/students
Suppose to use student data api we have been provided above link 
by UGC(org which keeps all university students data). 
api services student data.

http://geekyshows.com/api/students
Base url: geekyshows.com
naming convention: api
endpoint: students

requests: 
GET: /api/students     will return json data [{'id:1', 'name':'rahul'}, {'id:2', 'name':'amit'}] 
request single student data
GET: /api/students/1   will return [{'id:1', 'name':'yash'}

POST: api/students  
{'name': 'anket'}   will insert data [{'id':11, 'name':'anket'}]


Django REST framework: 
It is a powerful and flexible toolkit for building WebApis.

Why to use DRF?
- You can test api while building it 
- You get OAuth1, OAuth2 packages in Authentication policies 
- Serialization supports both ORM and non ORM data sources. 

pip install djangorestframework 

INstalled_apps = [
'rest_framework'
]


prerequieste for - Serializers
Python-json
python has a builtin package called json used to work with json data.

.dumps(data)- This is used to convert python object into json string.
e.g.: 
import json
python_data = {'name':'amit', 'rollno':100}
json_data = json.dumps(python_data)
print(json_Data) ==> {"name":"amit", "rollno":100}
// json data is always in double quotes ""

.loads(data)- This is used to parse json string.
e.g.: 
json_data = {"name":"amit", "rollno":100}
parsed_data = json.loads(json_data)
print(parsed_data) ==> {'name':'amit', 'rollno':100}


Serializers:
serializers are responsible for converting complex data such as querysets
or model objects to native python datatypes called serialization. That can
be easily rendered into JSON, XML or other content types which is easily 
understandable by Front End. 

Serializers are also responsible for desrialization which means it allows
parsed data to be converted back into complex types, after first 
validating incoming data.     

Serializer class: 
DRF provides a Serializer class which gives you a powerful, generic way
to control the ouput of your responses.

How to create serializer class?
Create a seprate serializer.py file to write all serializers.

from rest_framework import serializers
class StudentSerializer(serializers.Serializer):
	name = serializers.CharField(max_length=100)
	rollno = serializers.IntegerField()
	city = serializers.CharField(max_length=100)

Flow of serializing data present in db:
translate the db data to json form and send it to client 
similarly, convert the json data comming from client to python datatype. 

We have records in table.
records means model objects 
model objects means complex data. 

complex Dataype---(a)--->Python Native DataType---(b)--->Json Data
a= seriialization, b = render into json
	
e.g.: 
 //Creating a model instance stu 
1) stu = Student.objects.get(id=1)
      //Converting a model instance stu to Python Dict/ Serializing object
2) serializer = StudentSerializer(stu)

//Creating a query set 
stu = Student.objects.all()
//Converting a queryset to list of python Dict/ Serializing queryset
serializer = StudentSerializer(stu, many=True)

* serializer.data 
This will show you the serialized data/python dict. 

* JSONRenderer
This is used to render serialized data into JSON which is understandable 
by FRONT end.

How to render serialized data into JSON using JSONRendered? 
from rest_framework.renderers import JSONRenderer
3) json_data = JSONRenderer().render(serializer.data)
// you can also use json.dumps() 

In 1) ,2) ,3) setps you extract data from db, serialize data, 
render serialized data into json.

* JsonResponse
JsonResponse(data, encoder=DjangoJSONEncoder, safe=True, 
		json_dumps_params=None, **kwargs)
- An httpResponse subclass that helps to create a JSON-encoded reponse. 
- Its default content type is set to application/json.
- The encoder is used to serialize the data.
- When safe is set to True, dict has to be passed, else raise typeerror. 
  if false any object is allowed. 


Serializer Fields: 
serializable fields are used in serializers to convert complex data 
types (like Django models) into JSON, and vice versa.

1) CharField(max_length=None, min_length=None, allow_blank=False,
	 trim_whitespace=True)
2) IntegerField(max_value=None, min_value=None)
3) FloatField(max_value=None, min_value=None)
4) DecimalField(max_digits, decimal_places, coerce_to_string=None, 
	max_value=None, min_value=None)
5) SlugField(max_length=50, min_length=None, allow_blank=False)
6) EmailField(max_length=None, min_length=None, allow_blank=False)
7) BooleanField()
8) NullBooleanField()
9) URLField(max_length=200, min_length=None, allow_blank=False)
10) FileField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)
11) ImageField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)
12) DateField(format=api_settings.DATE_FORMAT, input_formats=None)
13) TimeField(format=api_settings.TIME_FORMAT, input_formats=None)
14) DateTimeField(format=api_settings.DATETIME_FORMAT, input_formats=None, default_timezone=None)
15) DurationField(max_value=None, min_value=None)
16) RegexField(regex, max_length=None, min_length=None, allow_blank=False)
17) UUIDField(format='hex_verbose')
18) FilePathField(path, match=None, recursive=False, allow_files=True, allow_folders=False, required=None, **kwargs)
19) IPAddressField(protocol='both', unpack_ipv4=False, **options)
20) ChoiceField(choices)
21) MultipleChoiceField(choices)
22) ListField(child=<A_FIELD_INSTANCE>, allow_empty=True, 
	min_length=None, max_length=None)
23) DictField(child=<A_FIELD_INSTANCE>, allow_empty=True)
24) HStoreField(child=<A_FIELD_INSTANCE>, allow_empty=True)
25) JSONField(binary, encoder)
26) ReadOnlyField()
27) HiddenField()
28) ModelField(model_field=<Django ModelField instance>)
29) SerializerMethodField(method_name=None)


Deserialization:
Serializers are also responsible for desrialization which means it allows
parsed data to be converted back into complex types, after first 
validating incoming data. 

flow? 
Json Data---(a)--->Python Native DataType---(b)--->complex Dataype
a: Parse Data 
b: Deserialization

Pre-requistes for Deserialization:
* BytesIO()
1) stream = io.BytesIO(json_data)
// will convert json_data to stream data/ continous flow of data/file 
like object.
This lets you process or parse the data as if it came from a file, 
making it easier to handle.

* JSONParser()
This let you parse json data to python native datatype. 
from rest_framework.parsers import JSONParser 
2) parsed_data = JSONParser().parse(stream)

Deserialization allows parsed data to be converted back into complex types, after first 
validating incoming data.

//Creating serializer Object 
3) serializer = StudentSerializer(data = parsed_data)
//validated data
4) serialize.is_valid()
// is_valid check if data is proper. e.g. max_length is satisfied, column is
integer depending on model definition. 

can view data using 
	> serializer.validated_data
	e.g.:
	{"name": "Amit", "roll": "100a", "city": "Mumbai"}
can view errors using 
	> serializer.errors 
	e.g.:
	{"name": "", "roll": "100a", "city": "Mumbai"}
	{'name': ['This field may not be blank.'], 'roll': ['A valid integer is required.']}

flow: we are converting json data to native python datatype
and then convert to complex datatype i.e. model object which can be insert 
into db table.  

When do we do deserialization ? 
when we want to insert, updatae, modify data sent from user. 
similarly, to get data we do serialization. 

Extra functions in serializer class while deserializing?
class StudentSreializer(serializers.Serializer):
	..

	def create(self, validated_data):
		return super().create(**validated_data)

Here validated_data contains dictionary. To pass dict you use **.  
This create method is executed when you call serializer.save(). This create
a new entry in table.  

CRUD operations with API: 
Till now we have seen Read, Create (GET, POST).
Update:
types?  
partial update 
complete update (all fields value)

Extra function in serializer class to update records? 
class StudentSerializer(serializers.Serializer):
	..
	
	def update(self, instance, validated_data):
		instance.name = validated_data.get('name', insatnce.name)
		insatnce.roll = validated_data.get('roll', instance.roll)
		instance.city = validated_data.get('city', insatnce.city)
		
		instance.save()
		return instance 

instance.name - old data stored in db 
validated_data - new data 

Complete update: 
originalModelObject = Student.objects.get(id=id) // entry to be updated  
serializer = StudentSerilaizer(originalModelObject, data=pythondata)
if serializer.is_valid()
	serializer.save()

Partial Update:
serializer = StudentSerializer(originalModelObject, data=pythondata, partial=True)
if serializer.is_valid():
	serializer.save()


Delete:
There is no extra function in StudentSreializer class to delete. 
Just identify the model object and delete. 
Student.objects.get(id=id).delete()

Function based View: 
def studentapi(request):
	if request.method == 'GET':
		..

urls.py 
from . import views
urlpatterns = [
	path('studentapi/', views.studentapi)
]



Class based Views:
from django.views import View 
class StudentAPI(View):
	def get(self, request, *args, **kwargs):
	// instead of if request.method == 'GET': we write functions
		.. 
		remaining code remains same 
	

urls.py 
from . import views
urlpatterns = [
	path('studentapi/', views.StudentAPI.as_view())
]



Validation:
types: 
-Field Level Validation 
-Object level 
-Validators

-Field Level Validation
We can specify field level validation by adding validate_fieldName()
methods to your Serializer subclass.
validate_filedName() method should return the validated value or raise
a serializers.ValidationError 
e.g.: 
class StudentSerializer(serializers.Serializer):
	name = serializers.CharField(max_length = 200)
	roll = serializers.IntegerField()
	city = serializers.CharField(max_length = 200)

	def validate_roll(self, value):
		if value >= 200:
			rasie serializers.ValidationError('Seat Full')
		return value 

//value is the value of the filed that need to be validated. 
//validate_roll is invoked when you call serialized_data.is_valid()

-Object Level Validation
When we need to do valdiation that requires multiple fields we do object 
level validation by adding method called validate() to Serialzer class.

validate() method should return the validated value or raise
a serializers.ValidationError 

e.g.:
def validate(self, data):
	name = data.get('name')
	city = data.get('city')
	if name.lower() == 'amit' and city.lower() != 'mumbai':
		raise serializers.ValidationError('City must be Mumbai')
	return data				
//data is dictionary of field values.


Validators:
You can create any function outside seriualzier class and mention it in serializer class field in validators paramete to
validate data.
e.g.:
	def starts_with_r(value):
	    if value['0'].lower() != 'r':
	       raise serializer.ValidationError('name dont start with r')

class StudentSerializer(serializers.Serializer):
	name = serializers.CharField(max_length=100,
				validators=[starts_with_r])

//Priority: 1) Validators, 2) field level validaton, 3) Object level
//Can apply all validation together.